import { TokenType, Scanner, IToken } from './ChoiceScriptScanner';
import * as nodes from './ChoiceScriptNodes';
import { CSIssueType } from './ChoiceScriptErrors';
import { TextDocument } from '../cssLanguageTypes';
export interface IMark {
    prev?: IToken;
    curr: IToken;
    offset: number;
}
export declare class ChoiceScriptParser {
    scanner: Scanner;
    token: IToken;
    prevToken?: IToken;
    indentType: nodes.IndentType | undefined;
    indentUnitSize: number;
    indentLevel: number;
    lineNum: number;
    private lastErrorToken?;
    constructor(indentUnit?: string, indentUnitSize?: number, scnr?: Scanner);
    peekIdent(text: string): boolean;
    peekKeyword(text: string): boolean;
    peekDelim(text: string): boolean;
    peek(type: TokenType): boolean;
    peekRegExp(type: TokenType, regEx: RegExp): boolean;
    hasWhitespace(): boolean;
    consumeToken(): void;
    mark(): IMark;
    restoreAtMark(mark: IMark): void;
    try(func: () => nodes.Node | null): nodes.Node | null;
    acceptOneKeyword(keywords: string[]): boolean;
    accept(type: TokenType): boolean;
    acceptIdent(text: string): boolean;
    acceptKeyword(text: string): boolean;
    acceptFromRawTextList(keywords: string[]): boolean;
    acceptDelim(text: string): boolean;
    acceptRegexp(regEx: RegExp): boolean;
    _parseRegexp(regEx: RegExp): nodes.Node;
    resync(resyncTokens: TokenType[] | undefined, resyncStopTokens: TokenType[] | undefined): boolean;
    createNode(nodeType: nodes.NodeType): nodes.Node;
    create<T>(ctor: nodes.NodeConstructor<T>): T;
    finish<T extends nodes.Node>(node: T, error?: CSIssueType, resyncTokens?: TokenType[], resyncStopTokens?: TokenType[]): T;
    markError<T extends nodes.Node>(node: T, error: CSIssueType, resyncTokens?: TokenType[], resyncStopTokens?: TokenType[]): void;
    parseScene(textDocument: TextDocument): nodes.Scene;
    internalParse<T extends nodes.Node, U extends T | null>(input: string, parseFunc: () => U, textProvider?: nodes.ITextProvider): U;
    _parseScene(textDocument: TextDocument): nodes.Scene;
    _parseLine(): nodes.Line;
    _parseVariableReplacement(): nodes.Node;
    _parseValueToken(token?: IToken): nodes.Node | null;
    _mapMissingParenToParseError(parenTokenType: TokenType): CSIssueType;
    _parseCSExpr(parenthetical?: TokenType, stopOffset?: number): nodes.Expression;
    _parseChoiceScriptFunction(): nodes.Node;
    _parseAnyCSOperator(): nodes.Operator;
    _parseImplicitCSOperator(): nodes.Operator;
    _parseNamedCSOperator(): nodes.Operator;
    _parseStandardCSOperator(): nodes.Operator;
    _parseBooleanCSOperator(): nodes.Operator;
    _parseFairMathCSOperator(): nodes.Operator;
    _parseMultireplaceBody(): nodes.Node;
    _parseFormatTags(): void;
    _parseWord(): nodes.RealWord;
    _addTextToNode(node: nodes.Node): boolean;
    _populateTextLine(line: nodes.Line): nodes.Line | null;
    _populateChoiceOptionLine(line: nodes.Line): nodes.Line | null;
    _populateChoiceScriptLine(line: nodes.Line): nodes.Node | null;
    _parseChoiceScriptStatement(): nodes.Node;
    _parseChoiceScriptComment(): nodes.Node;
    _parseChoiceScriptCommand(): nodes.Node;
    _parseLabelDeclaration(): nodes.LabelDeclaration;
    _parseVariableDeclaration(): nodes.VariableDeclaration;
    _parseVariableReference(parenthetical?: TokenType): nodes.Variable;
    _parseLabel(): nodes.Label | null;
    _parseVariable(): nodes.Variable | null;
    _parseTIdent<T>(type: nodes.NodeConstructor<T>): T | null;
    _parseLabelRef(): nodes.LabelRef | null;
    _parseSceneRef(): nodes.SceneRef | null;
    _parseGoCommandBody(flowCommand: nodes.Node, name: string | undefined): void;
    _parseFlowCommand(): nodes.FlowCommand;
    _parseIfCommand(inline?: boolean): nodes.Node | null;
    _parseReuseCommand(): nodes.Node;
    _parseChoiceOptionLine(): nodes.ChoiceOption | null;
    _parseIfBlock(guardsChoiceOption?: boolean): nodes.Node | null;
    _parseChoiceOptionText(): nodes.ChoiceOption;
    _parseChoiceCommand(): nodes.ChoiceCommand | null;
    _parseSetCommand(): nodes.SetCommand;
    _parseStandardCommand(): nodes.StandardCommand;
    _parseInvalidCommand(): nodes.Command;
    _needsSemicolonAfter(node: nodes.Node): boolean;
    _parseNumericalOperator(): nodes.Operator;
    _parseSelectorIdent(): nodes.Node;
    _parseHash(): nodes.Node;
    _parseExpr(stopOnComma?: boolean): nodes.Expression;
    _parseFairMathExpr(): nodes.Expression | null;
    _parseBoolean(): nodes.BinaryExpression;
    _parseNumericalLiteral(): nodes.NumericValue;
    _parseNumericalExpression(): nodes.Expression | null;
    _parseStringExpression(): nodes.StringExpression | null;
    _parseStringLiteral(): nodes.StringValue | null;
    _parseIdent(referenceTypes?: nodes.ReferenceType[]): nodes.Identifier | null;
    _parseIndentation(checkIndentLevel?: boolean): nodes.Indentation | null;
}
