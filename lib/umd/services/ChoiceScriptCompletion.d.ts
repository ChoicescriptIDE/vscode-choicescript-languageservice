import * as nodes from '../parser/ChoiceScriptNodes';
import { Symbols } from '../parser/ChoiceScriptSymbolScope';
import * as languageFacts from '../languageFacts/choicescriptFacts';
import { ICompletionParticipant, LanguageSettings, ClientCapabilities, TextDocument, Position, CompletionList, Range } from '../cssLanguageTypes';
export declare class ChoiceScriptCompletion {
    variablePrefix: string | null;
    private clientCapabilities;
    private settings?;
    private supportsMarkdown;
    position: Position;
    offset: number;
    currentWord: string;
    textDocument: TextDocument;
    scene: nodes.Scene;
    symbolContext: Symbols;
    defaultReplaceRange: Range;
    nodePath: nodes.Node[];
    completionParticipants: ICompletionParticipant[];
    typo: any;
    constructor(variablePrefix: string | null, clientCapabilities: ClientCapabilities | undefined);
    configure(settings?: LanguageSettings): void;
    protected getSymbolContext(scene?: nodes.Scene): Symbols;
    setCompletionParticipants(registeredCompletionParticipants: ICompletionParticipant[]): void;
    doComplete(document: TextDocument, position: Position, scene: nodes.Scene, suggestSpelling?: boolean): Promise<CompletionList>;
    protected isImportPathParent(type: nodes.NodeType): boolean;
    private finalize;
    private findInNodePath;
    private valueTypes;
    getCompletionsForIdentifier(result: CompletionList): CompletionList;
    getCompletionsForCommands(result: CompletionList): CompletionList;
    getSuggestionsForSpellings(result: CompletionList): Promise<CompletionList>;
    getCSSWideKeywordProposals(entry: languageFacts.IEntry, existingNode: nodes.Node | null, result: CompletionList): CompletionList;
    getLabelProposals(existingNode: nodes.Node, sceneUri: string, result: CompletionList): CompletionList;
    getSceneProposals(existingNode: nodes.Node, sceneUri: string, result: CompletionList): CompletionList;
    getVariableProposals(existingNode: nodes.Node, sceneUri: string, result: CompletionList): CompletionList;
    getUnitProposals(entry: languageFacts.IEntry, existingNode: nodes.Node | null, result: CompletionList): CompletionList;
    protected getCompletionRange(existingNode: nodes.Node | null): Range;
    protected getPositionProposals(entry: languageFacts.IEntry, existingNode: nodes.Node | null, result: CompletionList): CompletionList;
    protected getRepeatStyleProposals(entry: languageFacts.IEntry, existingNode: nodes.Node | null, result: CompletionList): CompletionList;
    protected getLineStyleProposals(entry: languageFacts.IEntry, existingNode: nodes.Node | null, result: CompletionList): CompletionList;
    protected getLineWidthProposals(entry: languageFacts.IEntry, existingNode: nodes.Node | null, result: CompletionList): CompletionList;
    protected getGeometryBoxProposals(entry: languageFacts.IEntry, existingNode: nodes.Node | null, result: CompletionList): CompletionList;
    protected getBoxProposals(entry: languageFacts.IEntry, existingNode: nodes.Node | null, result: CompletionList): CompletionList;
    protected getImageProposals(entry: languageFacts.IEntry, existingNode: nodes.Node | null, result: CompletionList): CompletionList;
    protected getTimingFunctionProposals(entry: languageFacts.IEntry, existingNode: nodes.Node | null, result: CompletionList): CompletionList;
    protected getBasicShapeProposals(entry: languageFacts.IEntry, existingNode: nodes.Node | null, result: CompletionList): CompletionList;
    getCompletionsForVariableDeclaration(declaration: nodes.VariableDeclaration, sceneUri: string, result: CompletionList): CompletionList;
    getCompletionForUriLiteralValue(uriLiteralNode: nodes.Node, result: CompletionList): CompletionList;
    getCompletionForImportPath(importPathNode: nodes.Node, result: CompletionList): CompletionList;
    private doesSupportMarkdown;
}
